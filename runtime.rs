#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
use codec::{Encode, Decode};
use frame_support::{
    decl_module, decl_storage, decl_event, decl_error, ensure, StorageValue,
    traits::{Randomness, Currency, ExistenceRequirement, Get},
    RuntimeDebug,
    dispatch::DispatchResult,
};
use sp_io::hashing::blake2_128;
use frame_system::{
    ensure_signed, ensure_none,
    offchain::{SendTransactionTypes, SubmitTransaction},
};
use sp_std::{vec::Vec, convert::TryInto};
use sp_runtime::{
    transaction_validity::{
        InvalidTransaction, TransactionSource, TransactionValidity, ValidTransaction,
    },
    offchain::storage_lock::{StorageLock, BlockAndTime},
    RandomNumberGenerator,
    traits::BlakeTwo256,
};
use orml_utilities::with_transaction_result;
use orml_nft::Module as NftModule;
#[cfg(feature = "std")]
use serde::{Deserialize, Serialize};
mod weights {
    //! Autogenerated weights for pallet_kitties
    //!
    //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 3.0.0
    //! DATE: 2021-05-02, STEPS: `[]`, REPEAT: 1, LOW RANGE: `[]`, HIGH RANGE: `[]`
    //! EXECUTION: None, WASM-EXECUTION: Interpreted, CHAIN: None, DB CACHE: 128
    #![allow(unused_parens)]
    #![allow(unused_imports)]
    use frame_support::{
        traits::Get,
        weights::{Weight, constants::RocksDbWeight},
    };
    use sp_std::marker::PhantomData;
    /// Weight functions needed for pallet_kitties.
    pub trait WeightInfo {
        fn create() -> Weight;
        fn breed() -> Weight;
        fn transfer() -> Weight;
        fn set_price() -> Weight;
        fn buy() -> Weight;
    }
    /// Weights for pallet_kitties using the Substrate node and recommended hardware.
    pub struct SubstrateWeight<T>(PhantomData<T>);
    impl<T: frame_system::Config> WeightInfo for SubstrateWeight<T> {
        fn create() -> Weight {
            (532_000_000 as Weight)
                .saturating_add(T::DbWeight::get().reads(5 as Weight))
                .saturating_add(T::DbWeight::get().writes(4 as Weight))
        }
        fn breed() -> Weight {
            (678_000_000 as Weight)
                .saturating_add(T::DbWeight::get().reads(7 as Weight))
                .saturating_add(T::DbWeight::get().writes(4 as Weight))
        }
        fn transfer() -> Weight {
            (439_000_000 as Weight)
                .saturating_add(T::DbWeight::get().reads(2 as Weight))
                .saturating_add(T::DbWeight::get().writes(4 as Weight))
        }
        fn set_price() -> Weight {
            (380_000_000 as Weight)
                .saturating_add(T::DbWeight::get().reads(3 as Weight))
                .saturating_add(T::DbWeight::get().writes(1 as Weight))
        }
        fn buy() -> Weight {
            (1_023_000_000 as Weight)
                .saturating_add(T::DbWeight::get().reads(4 as Weight))
                .saturating_add(T::DbWeight::get().writes(5 as Weight))
        }
    }
    impl WeightInfo for () {
        fn create() -> Weight {
            (532_000_000 as Weight)
                .saturating_add(RocksDbWeight::get().reads(5 as Weight))
                .saturating_add(RocksDbWeight::get().writes(4 as Weight))
        }
        fn breed() -> Weight {
            (678_000_000 as Weight)
                .saturating_add(RocksDbWeight::get().reads(7 as Weight))
                .saturating_add(RocksDbWeight::get().writes(4 as Weight))
        }
        fn transfer() -> Weight {
            (439_000_000 as Weight)
                .saturating_add(RocksDbWeight::get().reads(2 as Weight))
                .saturating_add(RocksDbWeight::get().writes(4 as Weight))
        }
        fn set_price() -> Weight {
            (380_000_000 as Weight)
                .saturating_add(RocksDbWeight::get().reads(3 as Weight))
                .saturating_add(RocksDbWeight::get().writes(1 as Weight))
        }
        fn buy() -> Weight {
            (1_023_000_000 as Weight)
                .saturating_add(RocksDbWeight::get().reads(4 as Weight))
                .saturating_add(RocksDbWeight::get().writes(5 as Weight))
        }
    }
}
pub use weights::WeightInfo;
pub struct Kitty(pub [u8; 16]);
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl _parity_scale_codec::Encode for Kitty {
        fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output + ?Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            _parity_scale_codec::Encode::encode_to(&&self.0, __codec_dest_edqy)
        }
        fn encode(&self) -> _parity_scale_codec::alloc::vec::Vec<u8> {
            _parity_scale_codec::Encode::encode(&&self.0)
        }
        fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {
            _parity_scale_codec::Encode::using_encoded(&&self.0, f)
        }
    }
    impl _parity_scale_codec::EncodeLike for Kitty {}
};
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl _parity_scale_codec::Decode for Kitty {
        fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> core::result::Result<Self, _parity_scale_codec::Error> {
            Ok(Kitty({
                let __codec_res_edqy =
                    <[u8; 16] as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                match __codec_res_edqy {
                    Err(e) => return Err(e.chain("Could not decode `Kitty.0`")),
                    Ok(__codec_res_edqy) => __codec_res_edqy,
                }
            }))
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Kitty {
    #[inline]
    fn clone(&self) -> Kitty {
        match *self {
            Kitty(ref __self_0_0) => Kitty(::core::clone::Clone::clone(&(*__self_0_0))),
        }
    }
}
impl core::fmt::Debug for Kitty {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_tuple("Kitty").field(&self.0).finish()
    }
}
impl ::core::marker::StructuralPartialEq for Kitty {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Kitty {
    #[inline]
    fn eq(&self, other: &Kitty) -> bool {
        match *other {
            Kitty(ref __self_1_0) => match *self {
                Kitty(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &Kitty) -> bool {
        match *other {
            Kitty(ref __self_1_0) => match *self {
                Kitty(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
            },
        }
    }
}
impl ::core::marker::StructuralEq for Kitty {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for Kitty {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<[u8; 16]>;
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Kitty {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            _serde::Serializer::serialize_newtype_struct(__serializer, "Kitty", &self.0)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Kitty {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Kitty>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Kitty;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "tuple struct Kitty")
                }
                #[inline]
                fn visit_newtype_struct<__E>(
                    self,
                    __e: __E,
                ) -> _serde::__private::Result<Self::Value, __E::Error>
                where
                    __E: _serde::Deserializer<'de>,
                {
                    let __field0: [u8; 16] =
                        match <[u8; 16] as _serde::Deserialize>::deserialize(__e) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    _serde::__private::Ok(Kitty(__field0))
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 =
                        match match _serde::de::SeqAccess::next_element::<[u8; 16]>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"tuple struct Kitty with 1 element",
                                ));
                            }
                        };
                    _serde::__private::Ok(Kitty(__field0))
                }
            }
            _serde::Deserializer::deserialize_newtype_struct(
                __deserializer,
                "Kitty",
                __Visitor {
                    marker: _serde::__private::PhantomData::<Kitty>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
pub enum KittyGender {
    Male,
    Female,
}
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl _parity_scale_codec::Encode for KittyGender {
        fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output + ?Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                KittyGender::Male => {
                    __codec_dest_edqy.push_byte(0usize as u8);
                }
                KittyGender::Female => {
                    __codec_dest_edqy.push_byte(1usize as u8);
                }
                _ => (),
            }
        }
    }
    impl _parity_scale_codec::EncodeLike for KittyGender {}
};
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl _parity_scale_codec::Decode for KittyGender {
        fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> core::result::Result<Self, _parity_scale_codec::Error> {
            match __codec_input_edqy.read_byte().map_err(|e| {
                e.chain("Could not decode `KittyGender`, failed to read variant byte")
            })? {
                __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(KittyGender::Male),
                __codec_x_edqy if __codec_x_edqy == 1usize as u8 => Ok(KittyGender::Female),
                _ => Err("Could not decode `KittyGender`, variant doesn\'t exist".into()),
            }
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for KittyGender {
    #[inline]
    fn clone(&self) -> KittyGender {
        {
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for KittyGender {}
impl core::fmt::Debug for KittyGender {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::Male => fmt.debug_tuple("KittyGender::Male").finish(),
            Self::Female => fmt.debug_tuple("KittyGender::Female").finish(),
            _ => Ok(()),
        }
    }
}
impl ::core::marker::StructuralPartialEq for KittyGender {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for KittyGender {
    #[inline]
    fn eq(&self, other: &KittyGender) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    _ => true,
                }
            } else {
                false
            }
        }
    }
}
impl ::core::marker::StructuralEq for KittyGender {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for KittyGender {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {}
    }
}
impl Kitty {
    pub fn gender(&self) -> KittyGender {
        if self.0[0] % 2 == 0 {
            KittyGender::Male
        } else {
            KittyGender::Female
        }
    }
}
pub trait Config:
    orml_nft::Config<TokenData = Kitty, ClassData = ()> + SendTransactionTypes<Call<Self>>
{
    type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;
    type Randomness: Randomness<Self::Hash>;
    type Currency: Currency<Self::AccountId>;
    type WeightInfo: WeightInfo;
    type DefaultDifficulty: Get<u32>;
}
type KittyIndexOf<T> = <T as orml_nft::Config>::TokenId;
type BalanceOf<T> =
    <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;
use self::sp_api_hidden_includes_decl_storage::hidden_include::{
    StorageValue as _, StorageMap as _, StorageDoubleMap as _, StoragePrefixedMap as _,
    IterableStorageMap as _, IterableStorageDoubleMap as _,
};
#[doc(hidden)]
mod sp_api_hidden_includes_decl_storage {
    pub extern crate frame_support as hidden_include;
}
trait Store {
    type KittyPrices;
    type ClassId;
    type AutoBreedNonce;
}
impl<T: Config + 'static> Store for Module<T> {
    type KittyPrices = KittyPrices<T>;
    type ClassId = ClassId<T>;
    type AutoBreedNonce = AutoBreedNonce;
}
impl<T: Config + 'static> Module<T> {
    /// Get kitty price. None means not for sale.
    pub fn kitty_prices<
        K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<
            KittyIndexOf<T>,
        >,
    >(
        key: K,
    ) -> Option<BalanceOf<T>> {
        < KittyPrices < T > as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: storage :: StorageMap < KittyIndexOf < T > , BalanceOf < T > > > :: get (key)
    }
    /// The class id for orml_nft
    pub fn class_id() -> T::ClassId {
        < ClassId < T > as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: storage :: StorageValue < T :: ClassId > > :: get ()
    }
    /// Nonce for auto breed to prevent replay attack
    pub fn auto_breed_nonce() -> u32 {
        < AutoBreedNonce < > as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: storage :: StorageValue < u32 > > :: get ()
    }
}
#[doc(hidden)]
pub struct __GetByteStructKittyPrices<T>(
    pub self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<(T)>,
);
#[cfg(feature = "std")]
#[allow(non_upper_case_globals)]
static __CACHE_GET_BYTE_STRUCT_KittyPrices:
    self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
    > = self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
#[cfg(feature = "std")]
impl<T: Config> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
    for __GetByteStructKittyPrices<T>
{
    fn default_byte(
        &self,
    ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8> {
        use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
        __CACHE_GET_BYTE_STRUCT_KittyPrices
            .get_or_init(|| {
                let def_val: Option<BalanceOf<T>> = Default::default();
                <Option<BalanceOf<T>> as Encode>::encode(&def_val)
            })
            .clone()
    }
}
unsafe impl<T: Config> Send for __GetByteStructKittyPrices<T> {}
unsafe impl<T: Config> Sync for __GetByteStructKittyPrices<T> {}
#[doc(hidden)]
pub struct __GetByteStructClassId<T>(
    pub self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<(T)>,
);
#[cfg(feature = "std")]
#[allow(non_upper_case_globals)]
static __CACHE_GET_BYTE_STRUCT_ClassId:
    self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
    > = self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
#[cfg(feature = "std")]
impl<T: Config> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
    for __GetByteStructClassId<T>
{
    fn default_byte(
        &self,
    ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8> {
        use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
        __CACHE_GET_BYTE_STRUCT_ClassId
            .get_or_init(|| {
                let def_val: T::ClassId = Default::default();
                <T::ClassId as Encode>::encode(&def_val)
            })
            .clone()
    }
}
unsafe impl<T: Config> Send for __GetByteStructClassId<T> {}
unsafe impl<T: Config> Sync for __GetByteStructClassId<T> {}
#[doc(hidden)]
pub struct __GetByteStructAutoBreedNonce<T>(
    pub self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<(T)>,
);
#[cfg(feature = "std")]
#[allow(non_upper_case_globals)]
static __CACHE_GET_BYTE_STRUCT_AutoBreedNonce:
    self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
    > = self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
#[cfg(feature = "std")]
impl<T: Config> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
    for __GetByteStructAutoBreedNonce<T>
{
    fn default_byte(
        &self,
    ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8> {
        use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
        __CACHE_GET_BYTE_STRUCT_AutoBreedNonce
            .get_or_init(|| {
                let def_val: u32 = Default::default();
                <u32 as Encode>::encode(&def_val)
            })
            .clone()
    }
}
unsafe impl<T: Config> Send for __GetByteStructAutoBreedNonce<T> {}
unsafe impl<T: Config> Sync for __GetByteStructAutoBreedNonce<T> {}
impl<T: Config + 'static> Module<T> {
    #[doc(hidden)]
    pub fn storage_metadata(
    ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata {
        self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageMetadata { prefix : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Kitties") , entries : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("KittyPrices") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Optional , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Map { hasher : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageHasher :: Blake2_128Concat , key : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("KittyIndexOf<T>") , value : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("BalanceOf<T>") , unused : false , } , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructKittyPrices :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [" Get kitty price. None means not for sale."]) , } , self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("ClassId") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Default , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Plain (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("T::ClassId")) , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructClassId :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [" The class id for orml_nft"]) , } , self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("AutoBreedNonce") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Default , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Plain (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("u32")) , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructAutoBreedNonce :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [" Nonce for auto breed to prevent replay attack"]) , }] [..]) , }
    }
}
/// Hidden instance generated to be internally used when module is used without
/// instance.
#[doc(hidden)]
pub struct __InherentHiddenInstance;
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for __InherentHiddenInstance {
    #[inline]
    fn clone(&self) -> __InherentHiddenInstance {
        match *self {
            __InherentHiddenInstance => __InherentHiddenInstance,
        }
    }
}
impl ::core::marker::StructuralEq for __InherentHiddenInstance {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for __InherentHiddenInstance {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {}
    }
}
impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for __InherentHiddenInstance {
    #[inline]
    fn eq(&self, other: &__InherentHiddenInstance) -> bool {
        match *other {
            __InherentHiddenInstance => match *self {
                __InherentHiddenInstance => true,
            },
        }
    }
}
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl _parity_scale_codec::Encode for __InherentHiddenInstance {
        fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output + ?Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
        }
    }
    impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance {}
};
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl _parity_scale_codec::Decode for __InherentHiddenInstance {
        fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> core::result::Result<Self, _parity_scale_codec::Error> {
            Ok(__InherentHiddenInstance)
        }
    }
};
impl core::fmt::Debug for __InherentHiddenInstance {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_tuple("__InherentHiddenInstance").finish()
    }
}
impl self::sp_api_hidden_includes_decl_storage::hidden_include::traits::Instance
    for __InherentHiddenInstance
{
    const PREFIX: &'static str = "Kitties";
}
/// Genesis config for the module, allow to build genesis storage.
#[cfg(feature = "std")]
#[serde(rename_all = "camelCase")]
#[serde(deny_unknown_fields)]
pub struct GenesisConfig {}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for GenesisConfig {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "GenesisConfig",
                false as usize,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for GenesisConfig {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {}
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"field index 0 <= i < 0",
                        )),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        _ => _serde::__private::Err(_serde::de::Error::unknown_field(
                            __value, FIELDS,
                        )),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(_serde::de::Error::unknown_field(
                                __value, FIELDS,
                            ))
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<GenesisConfig>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = GenesisConfig;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "struct GenesisConfig")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    _: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    _serde::__private::Ok(GenesisConfig {})
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    _serde::__private::Option::map(
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        },
                        |__impossible| match __impossible {},
                    );
                    _serde::__private::Ok(GenesisConfig {})
                }
            }
            const FIELDS: &'static [&'static str] = &[];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "GenesisConfig",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<GenesisConfig>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[cfg(feature = "std")]
impl Default for GenesisConfig {
    fn default() -> Self {
        GenesisConfig {}
    }
}
#[cfg(feature = "std")]
impl GenesisConfig {
    /// Build the storage for this module.
    pub fn build_storage<T: Config>(
        &self,
    ) -> std::result::Result<
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::Storage,
        String,
    > {
        let mut storage = Default::default();
        self.assimilate_storage::<T>(&mut storage)?;
        Ok(storage)
    }
    /// Assimilate the storage for this module into pre-existing overlays.
    pub fn assimilate_storage<T: Config>(
        &self,
        storage : & mut self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_runtime :: Storage,
    ) -> std::result::Result<(), String> {
        self :: sp_api_hidden_includes_decl_storage :: hidden_include :: BasicExternalities :: execute_with_storage (storage , | | { let extra_genesis_builder : fn (& Self) = | _config | { let class_id = NftModule :: < T > :: create_class (& Default :: default () , Vec :: new () , ()) . expect ("Cannot fail or invalid chain spec") ; ClassId :: < T > :: put (class_id) ; } ; extra_genesis_builder (self) ; Ok (()) })
    }
}
#[cfg(feature = "std")]
impl<
        T: Config,
        __GeneratedInstance: self::sp_api_hidden_includes_decl_storage::hidden_include::traits::Instance,
    >
    self::sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::BuildModuleGenesisStorage<
        T,
        __GeneratedInstance,
    > for GenesisConfig
{
    fn build_module_genesis_storage(
        &self,
        storage : & mut self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_runtime :: Storage,
    ) -> std::result::Result<(), String> {
        self.assimilate_storage::<T>(storage)
    }
}
/// Get kitty price. None means not for sale.
pub struct KittyPrices<T: Config>(
    self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<(T,)>,
);
impl<T: Config>
    self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StoragePrefixedMap<
        BalanceOf<T>,
    > for KittyPrices<T>
{
    fn module_prefix() -> &'static [u8] {
        < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
    }
    fn storage_prefix() -> &'static [u8] {
        b"KittyPrices"
    }
}
impl<T: Config>
    self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<
        KittyIndexOf<T>,
        BalanceOf<T>,
    > for KittyPrices<T>
{
    type Query = Option<BalanceOf<T>>;
    type Hasher = self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_128Concat;
    fn module_prefix() -> &'static [u8] {
        < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
    }
    fn storage_prefix() -> &'static [u8] {
        b"KittyPrices"
    }
    fn from_optional_value_to_query(v: Option<BalanceOf<T>>) -> Self::Query {
        v.or_else(|| Default::default())
    }
    fn from_query_to_optional_value(v: Self::Query) -> Option<BalanceOf<T>> {
        v
    }
}
/// The class id for orml_nft
pub struct ClassId<T: Config>(
    self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<(T,)>,
);
impl<T: Config>
    self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageValue<
        T::ClassId,
    > for ClassId<T>
{
    type Query = T::ClassId;
    fn module_prefix() -> &'static [u8] {
        < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
    }
    fn storage_prefix() -> &'static [u8] {
        b"ClassId"
    }
    fn from_optional_value_to_query(v: Option<T::ClassId>) -> Self::Query {
        v.unwrap_or_else(|| Default::default())
    }
    fn from_query_to_optional_value(v: Self::Query) -> Option<T::ClassId> {
        Some(v)
    }
}
/// Nonce for auto breed to prevent replay attack
pub struct AutoBreedNonce(
    self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<()>,
);
impl
    self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageValue<u32>
    for AutoBreedNonce
{
    type Query = u32;
    fn module_prefix() -> &'static [u8] {
        < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
    }
    fn storage_prefix() -> &'static [u8] {
        b"AutoBreedNonce"
    }
    fn from_optional_value_to_query(v: Option<u32>) -> Self::Query {
        v.unwrap_or_else(|| Default::default())
    }
    fn from_query_to_optional_value(v: Self::Query) -> Option<u32> {
        Some(v)
    }
}
/// [`RawEvent`] specialized for the configuration [`Config`]
///
/// [`RawEvent`]: enum.RawEvent.html
/// [`Config`]: trait.Config.html
pub type Event<T> = RawEvent<<T as frame_system::Config>::AccountId, KittyIndexOf<T>, BalanceOf<T>>;
/// Events for this module.
///
pub enum RawEvent<AccountId, KittyIndex, Balance> {
    /// A kitty is created. \[owner, kitty_id, kitty\]
    KittyCreated(AccountId, KittyIndex, Kitty),
    /// A new kitten is bred. \[owner, kitty_id, kitty\]
    KittyBred(AccountId, KittyIndex, Kitty),
    /// A kitty is transferred. \[from, to, kitty_id\]
    KittyTransferred(AccountId, AccountId, KittyIndex),
    /// The price for a kitty is updated. \[owner, kitty_id, price\]
    KittyPriceUpdated(AccountId, KittyIndex, Option<Balance>),
    /// A kitty is sold. \[old_owner, new_owner, kitty_id, price\]
    KittySold(AccountId, AccountId, KittyIndex, Balance),
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<
        AccountId: ::core::clone::Clone,
        KittyIndex: ::core::clone::Clone,
        Balance: ::core::clone::Clone,
    > ::core::clone::Clone for RawEvent<AccountId, KittyIndex, Balance>
{
    #[inline]
    fn clone(&self) -> RawEvent<AccountId, KittyIndex, Balance> {
        match (&*self,) {
            (&RawEvent::KittyCreated(ref __self_0, ref __self_1, ref __self_2),) => {
                RawEvent::KittyCreated(
                    ::core::clone::Clone::clone(&(*__self_0)),
                    ::core::clone::Clone::clone(&(*__self_1)),
                    ::core::clone::Clone::clone(&(*__self_2)),
                )
            }
            (&RawEvent::KittyBred(ref __self_0, ref __self_1, ref __self_2),) => {
                RawEvent::KittyBred(
                    ::core::clone::Clone::clone(&(*__self_0)),
                    ::core::clone::Clone::clone(&(*__self_1)),
                    ::core::clone::Clone::clone(&(*__self_2)),
                )
            }
            (&RawEvent::KittyTransferred(ref __self_0, ref __self_1, ref __self_2),) => {
                RawEvent::KittyTransferred(
                    ::core::clone::Clone::clone(&(*__self_0)),
                    ::core::clone::Clone::clone(&(*__self_1)),
                    ::core::clone::Clone::clone(&(*__self_2)),
                )
            }
            (&RawEvent::KittyPriceUpdated(ref __self_0, ref __self_1, ref __self_2),) => {
                RawEvent::KittyPriceUpdated(
                    ::core::clone::Clone::clone(&(*__self_0)),
                    ::core::clone::Clone::clone(&(*__self_1)),
                    ::core::clone::Clone::clone(&(*__self_2)),
                )
            }
            (&RawEvent::KittySold(ref __self_0, ref __self_1, ref __self_2, ref __self_3),) => {
                RawEvent::KittySold(
                    ::core::clone::Clone::clone(&(*__self_0)),
                    ::core::clone::Clone::clone(&(*__self_1)),
                    ::core::clone::Clone::clone(&(*__self_2)),
                    ::core::clone::Clone::clone(&(*__self_3)),
                )
            }
        }
    }
}
impl<AccountId, KittyIndex, Balance> ::core::marker::StructuralPartialEq
    for RawEvent<AccountId, KittyIndex, Balance>
{
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<
        AccountId: ::core::cmp::PartialEq,
        KittyIndex: ::core::cmp::PartialEq,
        Balance: ::core::cmp::PartialEq,
    > ::core::cmp::PartialEq for RawEvent<AccountId, KittyIndex, Balance>
{
    #[inline]
    fn eq(&self, other: &RawEvent<AccountId, KittyIndex, Balance>) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (
                        &RawEvent::KittyCreated(ref __self_0, ref __self_1, ref __self_2),
                        &RawEvent::KittyCreated(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                    ) => {
                        (*__self_0) == (*__arg_1_0)
                            && (*__self_1) == (*__arg_1_1)
                            && (*__self_2) == (*__arg_1_2)
                    }
                    (
                        &RawEvent::KittyBred(ref __self_0, ref __self_1, ref __self_2),
                        &RawEvent::KittyBred(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                    ) => {
                        (*__self_0) == (*__arg_1_0)
                            && (*__self_1) == (*__arg_1_1)
                            && (*__self_2) == (*__arg_1_2)
                    }
                    (
                        &RawEvent::KittyTransferred(ref __self_0, ref __self_1, ref __self_2),
                        &RawEvent::KittyTransferred(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                    ) => {
                        (*__self_0) == (*__arg_1_0)
                            && (*__self_1) == (*__arg_1_1)
                            && (*__self_2) == (*__arg_1_2)
                    }
                    (
                        &RawEvent::KittyPriceUpdated(ref __self_0, ref __self_1, ref __self_2),
                        &RawEvent::KittyPriceUpdated(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                    ) => {
                        (*__self_0) == (*__arg_1_0)
                            && (*__self_1) == (*__arg_1_1)
                            && (*__self_2) == (*__arg_1_2)
                    }
                    (
                        &RawEvent::KittySold(
                            ref __self_0,
                            ref __self_1,
                            ref __self_2,
                            ref __self_3,
                        ),
                        &RawEvent::KittySold(
                            ref __arg_1_0,
                            ref __arg_1_1,
                            ref __arg_1_2,
                            ref __arg_1_3,
                        ),
                    ) => {
                        (*__self_0) == (*__arg_1_0)
                            && (*__self_1) == (*__arg_1_1)
                            && (*__self_2) == (*__arg_1_2)
                            && (*__self_3) == (*__arg_1_3)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &RawEvent<AccountId, KittyIndex, Balance>) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (
                        &RawEvent::KittyCreated(ref __self_0, ref __self_1, ref __self_2),
                        &RawEvent::KittyCreated(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                    ) => {
                        (*__self_0) != (*__arg_1_0)
                            || (*__self_1) != (*__arg_1_1)
                            || (*__self_2) != (*__arg_1_2)
                    }
                    (
                        &RawEvent::KittyBred(ref __self_0, ref __self_1, ref __self_2),
                        &RawEvent::KittyBred(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                    ) => {
                        (*__self_0) != (*__arg_1_0)
                            || (*__self_1) != (*__arg_1_1)
                            || (*__self_2) != (*__arg_1_2)
                    }
                    (
                        &RawEvent::KittyTransferred(ref __self_0, ref __self_1, ref __self_2),
                        &RawEvent::KittyTransferred(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                    ) => {
                        (*__self_0) != (*__arg_1_0)
                            || (*__self_1) != (*__arg_1_1)
                            || (*__self_2) != (*__arg_1_2)
                    }
                    (
                        &RawEvent::KittyPriceUpdated(ref __self_0, ref __self_1, ref __self_2),
                        &RawEvent::KittyPriceUpdated(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                    ) => {
                        (*__self_0) != (*__arg_1_0)
                            || (*__self_1) != (*__arg_1_1)
                            || (*__self_2) != (*__arg_1_2)
                    }
                    (
                        &RawEvent::KittySold(
                            ref __self_0,
                            ref __self_1,
                            ref __self_2,
                            ref __self_3,
                        ),
                        &RawEvent::KittySold(
                            ref __arg_1_0,
                            ref __arg_1_1,
                            ref __arg_1_2,
                            ref __arg_1_3,
                        ),
                    ) => {
                        (*__self_0) != (*__arg_1_0)
                            || (*__self_1) != (*__arg_1_1)
                            || (*__self_2) != (*__arg_1_2)
                            || (*__self_3) != (*__arg_1_3)
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                true
            }
        }
    }
}
impl<AccountId, KittyIndex, Balance> ::core::marker::StructuralEq
    for RawEvent<AccountId, KittyIndex, Balance>
{
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<AccountId: ::core::cmp::Eq, KittyIndex: ::core::cmp::Eq, Balance: ::core::cmp::Eq>
    ::core::cmp::Eq for RawEvent<AccountId, KittyIndex, Balance>
{
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<AccountId>;
            let _: ::core::cmp::AssertParamIsEq<KittyIndex>;
            let _: ::core::cmp::AssertParamIsEq<Kitty>;
            let _: ::core::cmp::AssertParamIsEq<AccountId>;
            let _: ::core::cmp::AssertParamIsEq<KittyIndex>;
            let _: ::core::cmp::AssertParamIsEq<Kitty>;
            let _: ::core::cmp::AssertParamIsEq<AccountId>;
            let _: ::core::cmp::AssertParamIsEq<AccountId>;
            let _: ::core::cmp::AssertParamIsEq<KittyIndex>;
            let _: ::core::cmp::AssertParamIsEq<AccountId>;
            let _: ::core::cmp::AssertParamIsEq<KittyIndex>;
            let _: ::core::cmp::AssertParamIsEq<Option<Balance>>;
            let _: ::core::cmp::AssertParamIsEq<AccountId>;
            let _: ::core::cmp::AssertParamIsEq<AccountId>;
            let _: ::core::cmp::AssertParamIsEq<KittyIndex>;
            let _: ::core::cmp::AssertParamIsEq<Balance>;
        }
    }
}
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl<AccountId, KittyIndex, Balance> _parity_scale_codec::Encode
        for RawEvent<AccountId, KittyIndex, Balance>
    where
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        Option<Balance>: _parity_scale_codec::Encode,
        Option<Balance>: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        Balance: _parity_scale_codec::Encode,
        Balance: _parity_scale_codec::Encode,
    {
        fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output + ?Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                RawEvent::KittyCreated(ref aa, ref ba, ref ca) => {
                    __codec_dest_edqy.push_byte(0usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ca, __codec_dest_edqy);
                }
                RawEvent::KittyBred(ref aa, ref ba, ref ca) => {
                    __codec_dest_edqy.push_byte(1usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ca, __codec_dest_edqy);
                }
                RawEvent::KittyTransferred(ref aa, ref ba, ref ca) => {
                    __codec_dest_edqy.push_byte(2usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ca, __codec_dest_edqy);
                }
                RawEvent::KittyPriceUpdated(ref aa, ref ba, ref ca) => {
                    __codec_dest_edqy.push_byte(3usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ca, __codec_dest_edqy);
                }
                RawEvent::KittySold(ref aa, ref ba, ref ca, ref da) => {
                    __codec_dest_edqy.push_byte(4usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ca, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(da, __codec_dest_edqy);
                }
                _ => (),
            }
        }
    }
    impl<AccountId, KittyIndex, Balance> _parity_scale_codec::EncodeLike
        for RawEvent<AccountId, KittyIndex, Balance>
    where
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        Option<Balance>: _parity_scale_codec::Encode,
        Option<Balance>: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        AccountId: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        KittyIndex: _parity_scale_codec::Encode,
        Balance: _parity_scale_codec::Encode,
        Balance: _parity_scale_codec::Encode,
    {
    }
};
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl<AccountId, KittyIndex, Balance> _parity_scale_codec::Decode
        for RawEvent<AccountId, KittyIndex, Balance>
    where
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        Option<Balance>: _parity_scale_codec::Decode,
        Option<Balance>: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        AccountId: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        KittyIndex: _parity_scale_codec::Decode,
        Balance: _parity_scale_codec::Decode,
        Balance: _parity_scale_codec::Decode,
    {
        fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> core::result::Result<Self, _parity_scale_codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| e.chain("Could not decode `RawEvent`, failed to read variant byte"))?
            {
                __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(RawEvent::<
                    AccountId,
                    KittyIndex,
                    Balance,
                >::KittyCreated(
                    {
                        let __codec_res_edqy =
                            <AccountId as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittyCreated.0`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndex as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittyCreated.1`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <Kitty as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittyCreated.2`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                __codec_x_edqy if __codec_x_edqy == 1usize as u8 => Ok(RawEvent::<
                    AccountId,
                    KittyIndex,
                    Balance,
                >::KittyBred(
                    {
                        let __codec_res_edqy =
                            <AccountId as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittyBred.0`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndex as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittyBred.1`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <Kitty as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittyBred.2`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                __codec_x_edqy if __codec_x_edqy == 2usize as u8 => Ok(RawEvent::<
                    AccountId,
                    KittyIndex,
                    Balance,
                >::KittyTransferred(
                    {
                        let __codec_res_edqy =
                            <AccountId as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(
                                    e.chain("Could not decode `RawEvent::KittyTransferred.0`")
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <AccountId as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(
                                    e.chain("Could not decode `RawEvent::KittyTransferred.1`")
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndex as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(
                                    e.chain("Could not decode `RawEvent::KittyTransferred.2`")
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                __codec_x_edqy if __codec_x_edqy == 3usize as u8 => Ok(RawEvent::<
                    AccountId,
                    KittyIndex,
                    Balance,
                >::KittyPriceUpdated(
                    {
                        let __codec_res_edqy =
                            <AccountId as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(
                                    e.chain("Could not decode `RawEvent::KittyPriceUpdated.0`")
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndex as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(
                                    e.chain("Could not decode `RawEvent::KittyPriceUpdated.1`")
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <Option<Balance> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(
                                    e.chain("Could not decode `RawEvent::KittyPriceUpdated.2`")
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                __codec_x_edqy if __codec_x_edqy == 4usize as u8 => Ok(RawEvent::<
                    AccountId,
                    KittyIndex,
                    Balance,
                >::KittySold(
                    {
                        let __codec_res_edqy =
                            <AccountId as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittySold.0`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <AccountId as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittySold.1`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndex as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittySold.2`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <Balance as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => {
                                return Err(e.chain("Could not decode `RawEvent::KittySold.3`"))
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                _ => Err("Could not decode `RawEvent`, variant doesn\'t exist".into()),
            }
        }
    }
};
impl<AccountId, KittyIndex, Balance> core::fmt::Debug for RawEvent<AccountId, KittyIndex, Balance>
where
    AccountId: core::fmt::Debug,
    KittyIndex: core::fmt::Debug,
    Balance: core::fmt::Debug,
{
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::KittyCreated(ref a0, ref a1, ref a2) => fmt
                .debug_tuple("RawEvent::KittyCreated")
                .field(a0)
                .field(a1)
                .field(a2)
                .finish(),
            Self::KittyBred(ref a0, ref a1, ref a2) => fmt
                .debug_tuple("RawEvent::KittyBred")
                .field(a0)
                .field(a1)
                .field(a2)
                .finish(),
            Self::KittyTransferred(ref a0, ref a1, ref a2) => fmt
                .debug_tuple("RawEvent::KittyTransferred")
                .field(a0)
                .field(a1)
                .field(a2)
                .finish(),
            Self::KittyPriceUpdated(ref a0, ref a1, ref a2) => fmt
                .debug_tuple("RawEvent::KittyPriceUpdated")
                .field(a0)
                .field(a1)
                .field(a2)
                .finish(),
            Self::KittySold(ref a0, ref a1, ref a2, ref a3) => fmt
                .debug_tuple("RawEvent::KittySold")
                .field(a0)
                .field(a1)
                .field(a2)
                .field(a3)
                .finish(),
            _ => Ok(()),
        }
    }
}
impl<AccountId, KittyIndex, Balance> From<RawEvent<AccountId, KittyIndex, Balance>> for () {
    fn from(_: RawEvent<AccountId, KittyIndex, Balance>) -> () {
        ()
    }
}
impl<AccountId, KittyIndex, Balance> RawEvent<AccountId, KittyIndex, Balance> {
    #[allow(dead_code)]
    #[doc(hidden)]
    pub fn metadata() -> &'static [::frame_support::event::EventMetadata] {
        &[
            ::frame_support::event::EventMetadata {
                name: ::frame_support::event::DecodeDifferent::Encode("KittyCreated"),
                arguments: ::frame_support::event::DecodeDifferent::Encode(&[
                    "AccountId",
                    "KittyIndex",
                    "Kitty",
                ]),
                documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                    r" A kitty is created. \[owner, kitty_id, kitty\]",
                ]),
            },
            ::frame_support::event::EventMetadata {
                name: ::frame_support::event::DecodeDifferent::Encode("KittyBred"),
                arguments: ::frame_support::event::DecodeDifferent::Encode(&[
                    "AccountId",
                    "KittyIndex",
                    "Kitty",
                ]),
                documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                    r" A new kitten is bred. \[owner, kitty_id, kitty\]",
                ]),
            },
            ::frame_support::event::EventMetadata {
                name: ::frame_support::event::DecodeDifferent::Encode("KittyTransferred"),
                arguments: ::frame_support::event::DecodeDifferent::Encode(&[
                    "AccountId",
                    "AccountId",
                    "KittyIndex",
                ]),
                documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                    r" A kitty is transferred. \[from, to, kitty_id\]",
                ]),
            },
            ::frame_support::event::EventMetadata {
                name: ::frame_support::event::DecodeDifferent::Encode("KittyPriceUpdated"),
                arguments: ::frame_support::event::DecodeDifferent::Encode(&[
                    "AccountId",
                    "KittyIndex",
                    "Option<Balance>",
                ]),
                documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                    r" The price for a kitty is updated. \[owner, kitty_id, price\]",
                ]),
            },
            ::frame_support::event::EventMetadata {
                name: ::frame_support::event::DecodeDifferent::Encode("KittySold"),
                arguments: ::frame_support::event::DecodeDifferent::Encode(&[
                    "AccountId",
                    "AccountId",
                    "KittyIndex",
                    "Balance",
                ]),
                documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                    r" A kitty is sold. \[old_owner, new_owner, kitty_id, price\]",
                ]),
            },
        ]
    }
}
pub enum Error<T: Config> {
    #[doc(hidden)]
    __Ignore(
        ::frame_support::sp_std::marker::PhantomData<(T,)>,
        ::frame_support::Never,
    ),
    InvalidKittyId,
    SameGender,
    NotOwner,
    NotForSale,
    PriceTooLow,
    BuyFromSelf,
}
impl<T: Config> ::frame_support::sp_std::fmt::Debug for Error<T> {
    fn fmt(
        &self,
        f: &mut ::frame_support::sp_std::fmt::Formatter<'_>,
    ) -> ::frame_support::sp_std::fmt::Result {
        f.write_str(self.as_str())
    }
}
impl<T: Config> Error<T> {
    fn as_u8(&self) -> u8 {
        match self {
            Error::__Ignore(_, _) => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["internal error: entered unreachable code: "],
                &match (&"`__Ignore` can never be constructed",) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::InvalidKittyId => 0,
            Error::SameGender => 0 + 1,
            Error::NotOwner => 0 + 1 + 1,
            Error::NotForSale => 0 + 1 + 1 + 1,
            Error::PriceTooLow => 0 + 1 + 1 + 1 + 1,
            Error::BuyFromSelf => 0 + 1 + 1 + 1 + 1 + 1,
        }
    }
    fn as_str(&self) -> &'static str {
        match self {
            Self::__Ignore(_, _) => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["internal error: entered unreachable code: "],
                &match (&"`__Ignore` can never be constructed",) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::InvalidKittyId => "InvalidKittyId",
            Error::SameGender => "SameGender",
            Error::NotOwner => "NotOwner",
            Error::NotForSale => "NotForSale",
            Error::PriceTooLow => "PriceTooLow",
            Error::BuyFromSelf => "BuyFromSelf",
        }
    }
}
impl<T: Config> From<Error<T>> for &'static str {
    fn from(err: Error<T>) -> &'static str {
        err.as_str()
    }
}
impl<T: Config> From<Error<T>> for ::frame_support::sp_runtime::DispatchError {
    fn from(err: Error<T>) -> Self {
        let index = <T::PalletInfo as ::frame_support::traits::PalletInfo>::index::<Module<T>>()
            .expect("Every active module has an index in the runtime; qed")
            as u8;
        ::frame_support::sp_runtime::DispatchError::Module {
            index,
            error: err.as_u8(),
            message: Some(err.as_str()),
        }
    }
}
impl<T: Config> ::frame_support::error::ModuleErrorMetadata for Error<T> {
    fn metadata() -> &'static [::frame_support::error::ErrorMetadata] {
        &[
            ::frame_support::error::ErrorMetadata {
                name: ::frame_support::error::DecodeDifferent::Encode("InvalidKittyId"),
                documentation: ::frame_support::error::DecodeDifferent::Encode(&[]),
            },
            ::frame_support::error::ErrorMetadata {
                name: ::frame_support::error::DecodeDifferent::Encode("SameGender"),
                documentation: ::frame_support::error::DecodeDifferent::Encode(&[]),
            },
            ::frame_support::error::ErrorMetadata {
                name: ::frame_support::error::DecodeDifferent::Encode("NotOwner"),
                documentation: ::frame_support::error::DecodeDifferent::Encode(&[]),
            },
            ::frame_support::error::ErrorMetadata {
                name: ::frame_support::error::DecodeDifferent::Encode("NotForSale"),
                documentation: ::frame_support::error::DecodeDifferent::Encode(&[]),
            },
            ::frame_support::error::ErrorMetadata {
                name: ::frame_support::error::DecodeDifferent::Encode("PriceTooLow"),
                documentation: ::frame_support::error::DecodeDifferent::Encode(&[]),
            },
            ::frame_support::error::ErrorMetadata {
                name: ::frame_support::error::DecodeDifferent::Encode("BuyFromSelf"),
                documentation: ::frame_support::error::DecodeDifferent::Encode(&[]),
            },
        ]
    }
}
pub struct Module<T: Config>(::frame_support::sp_std::marker::PhantomData<(T,)>);
#[automatically_derived]
#[allow(unused_qualifications)]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for Module<T> {
    #[inline]
    fn clone(&self) -> Module<T> {
        match *self {
            Module(ref __self_0_0) => Module(::core::clone::Clone::clone(&(*__self_0_0))),
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<T: ::core::marker::Copy + Config> ::core::marker::Copy for Module<T> {}
impl<T: Config> ::core::marker::StructuralPartialEq for Module<T> {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for Module<T> {
    #[inline]
    fn eq(&self, other: &Module<T>) -> bool {
        match *other {
            Module(ref __self_1_0) => match *self {
                Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &Module<T>) -> bool {
        match *other {
            Module(ref __self_1_0) => match *self {
                Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
            },
        }
    }
}
impl<T: Config> ::core::marker::StructuralEq for Module<T> {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<T: ::core::cmp::Eq + Config> ::core::cmp::Eq for Module<T> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<
                ::frame_support::sp_std::marker::PhantomData<(T,)>,
            >;
        }
    }
}
impl<T: Config> core::fmt::Debug for Module<T>
where
    T: core::fmt::Debug,
{
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_tuple("Module").field(&self.0).finish()
    }
}
impl<T: frame_system::Config + Config>
    ::frame_support::traits::OnInitialize<<T as frame_system::Config>::BlockNumber> for Module<T>
{
}
impl<T: Config> ::frame_support::traits::OnRuntimeUpgrade for Module<T> {
    fn on_runtime_upgrade() -> ::frame_support::dispatch::Weight {
        let __within_span__ = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                use ::tracing::__macro_support::MacroCallsite;
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "on_runtime_upgrade",
                        "pallet_kitties",
                        ::tracing::Level::TRACE,
                        Some("pallets/kitties/src/lib.rs"),
                        Some(110u32),
                        Some("pallet_kitties"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                MacroCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && CALLSITE.is_enabled(interest)
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = CALLSITE.disabled_span();
                {};
                span
            }
        };
        let __tracing_guard__ = __within_span__.enter();
        frame_support::traits::PalletVersion {
            major: 0u16,
            minor: 1u8,
            patch: 0u8,
        }
        .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
        <<T as frame_system::Config>::DbWeight as ::frame_support::traits::Get<_>>::get().writes(1)
    }
}
impl<T: frame_system::Config + Config>
    ::frame_support::traits::OnFinalize<<T as frame_system::Config>::BlockNumber> for Module<T>
{
}
impl<T: frame_system::Config + Config>
    ::frame_support::traits::OffchainWorker<<T as frame_system::Config>::BlockNumber>
    for Module<T>
{
    fn offchain_worker(_now: T::BlockNumber) {
        let _ = Self::run_offchain_worker();
    }
}
impl<T: Config> Module<T> {
    /// Deposits an event using `frame_system::Module::deposit_event`.
    fn deposit_event(event: impl Into<<T as Config>::Event>) {
        <frame_system::Module<T>>::deposit_event(event.into())
    }
}
#[cfg(feature = "std")]
impl<T: Config> ::frame_support::traits::IntegrityTest for Module<T> {}
/// Can also be called using [`Call`].
///
/// [`Call`]: enum.Call.html
impl<T: Config> Module<T> {
    #[allow(unreachable_code)]
    /// Create a new kitty
    ///
    /// NOTE: Calling this function will bypass origin filters.
    pub fn create(origin: T::Origin) -> ::frame_support::dispatch::DispatchResult {
        let __within_span__ = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                use ::tracing::__macro_support::MacroCallsite;
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "create",
                        "pallet_kitties",
                        ::tracing::Level::TRACE,
                        Some("pallets/kitties/src/lib.rs"),
                        Some(110u32),
                        Some("pallet_kitties"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                MacroCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && CALLSITE.is_enabled(interest)
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = CALLSITE.disabled_span();
                {};
                span
            }
        };
        let __tracing_guard__ = __within_span__.enter();
        {
            let sender = ensure_signed(origin)?;
            let dna = Self::random_value(&sender);
            let kitty = Kitty(dna);
            let kitty_id =
                NftModule::<T>::mint(&sender, Self::class_id(), Vec::new(), kitty.clone())?;
            Self::deposit_event(RawEvent::KittyCreated(sender, kitty_id, kitty));
        }
        Ok(())
    }
    #[allow(unreachable_code)]
    /// Breed kitties
    ///
    /// NOTE: Calling this function will bypass origin filters.
    pub fn breed(
        origin: T::Origin,
        kitty_id_1: KittyIndexOf<T>,
        kitty_id_2: KittyIndexOf<T>,
    ) -> ::frame_support::dispatch::DispatchResult {
        let __within_span__ = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                use ::tracing::__macro_support::MacroCallsite;
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "breed",
                        "pallet_kitties",
                        ::tracing::Level::TRACE,
                        Some("pallets/kitties/src/lib.rs"),
                        Some(110u32),
                        Some("pallet_kitties"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                MacroCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && CALLSITE.is_enabled(interest)
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = CALLSITE.disabled_span();
                {};
                span
            }
        };
        let __tracing_guard__ = __within_span__.enter();
        {
            let sender = ensure_signed(origin)?;
            let kitty1 = Self::kitties(&sender, kitty_id_1).ok_or(Error::<T>::InvalidKittyId)?;
            let kitty2 = Self::kitties(&sender, kitty_id_2).ok_or(Error::<T>::InvalidKittyId)?;
            Self::do_breed(sender, kitty1, kitty2)?;
        }
        Ok(())
    }
    #[allow(unreachable_code)]
    /// Transfer a kitty to new owner
    ///
    /// NOTE: Calling this function will bypass origin filters.
    pub fn transfer(
        origin: T::Origin,
        to: T::AccountId,
        kitty_id: KittyIndexOf<T>,
    ) -> ::frame_support::dispatch::DispatchResult {
        let __within_span__ = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                use ::tracing::__macro_support::MacroCallsite;
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "transfer",
                        "pallet_kitties",
                        ::tracing::Level::TRACE,
                        Some("pallets/kitties/src/lib.rs"),
                        Some(110u32),
                        Some("pallet_kitties"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                MacroCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && CALLSITE.is_enabled(interest)
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = CALLSITE.disabled_span();
                {};
                span
            }
        };
        let __tracing_guard__ = __within_span__.enter();
        {
            let sender = ensure_signed(origin)?;
            NftModule::<T>::transfer(&sender, &to, (Self::class_id(), kitty_id))?;
            if sender != to {
                KittyPrices::<T>::remove(kitty_id);
                Self::deposit_event(RawEvent::KittyTransferred(sender, to, kitty_id));
            }
        }
        Ok(())
    }
    #[allow(unreachable_code)]
    /// Set a price for a kitty for sale
    /// None to delist the kitty
    ///
    /// NOTE: Calling this function will bypass origin filters.
    pub fn set_price(
        origin: T::Origin,
        kitty_id: KittyIndexOf<T>,
        new_price: Option<BalanceOf<T>>,
    ) -> ::frame_support::dispatch::DispatchResult {
        let __within_span__ = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                use ::tracing::__macro_support::MacroCallsite;
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "set_price",
                        "pallet_kitties",
                        ::tracing::Level::TRACE,
                        Some("pallets/kitties/src/lib.rs"),
                        Some(110u32),
                        Some("pallet_kitties"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                MacroCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && CALLSITE.is_enabled(interest)
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = CALLSITE.disabled_span();
                {};
                span
            }
        };
        let __tracing_guard__ = __within_span__.enter();
        {
            let sender = ensure_signed(origin)?;
            {
                if !orml_nft::TokensByOwner::<T>::contains_key(
                    &sender,
                    (Self::class_id(), kitty_id),
                ) {
                    {
                        return Err(Error::<T>::NotOwner.into());
                    };
                }
            };
            KittyPrices::<T>::mutate_exists(kitty_id, |price| *price = new_price);
            Self::deposit_event(RawEvent::KittyPriceUpdated(sender, kitty_id, new_price));
        }
        Ok(())
    }
    #[allow(unreachable_code)]
    /// Buy a kitty
    ///
    /// NOTE: Calling this function will bypass origin filters.
    pub fn buy(
        origin: T::Origin,
        owner: T::AccountId,
        kitty_id: KittyIndexOf<T>,
        max_price: BalanceOf<T>,
    ) -> ::frame_support::dispatch::DispatchResult {
        let __within_span__ = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                use ::tracing::__macro_support::MacroCallsite;
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "buy",
                        "pallet_kitties",
                        ::tracing::Level::TRACE,
                        Some("pallets/kitties/src/lib.rs"),
                        Some(110u32),
                        Some("pallet_kitties"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                MacroCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && CALLSITE.is_enabled(interest)
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = CALLSITE.disabled_span();
                {};
                span
            }
        };
        let __tracing_guard__ = __within_span__.enter();
        {
            let sender = ensure_signed(origin)?;
            {
                if !(sender != owner) {
                    {
                        return Err(Error::<T>::BuyFromSelf.into());
                    };
                }
            };
            KittyPrices::<T>::try_mutate_exists(kitty_id, |price| -> DispatchResult {
                let price = price.take().ok_or(Error::<T>::NotForSale)?;
                {
                    if !(max_price >= price) {
                        {
                            return Err(Error::<T>::PriceTooLow.into());
                        };
                    }
                };
                with_transaction_result(|| {
                    NftModule::<T>::transfer(&owner, &sender, (Self::class_id(), kitty_id))?;
                    T::Currency::transfer(&sender, &owner, price, ExistenceRequirement::KeepAlive)?;
                    Self::deposit_event(RawEvent::KittySold(owner, sender, kitty_id, price));
                    Ok(())
                })
            })?;
        }
        Ok(())
    }
    #[allow(unreachable_code)]
    ///
    /// NOTE: Calling this function will bypass origin filters.
    pub fn auto_breed(
        origin: T::Origin,
        kitty_id_1: KittyIndexOf<T>,
        kitty_id_2: KittyIndexOf<T>,
        _nonce: u32,
        _solution: u128,
    ) -> ::frame_support::dispatch::DispatchResult {
        let __within_span__ = {
            use ::tracing::__macro_support::Callsite as _;
            static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                use ::tracing::__macro_support::MacroCallsite;
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "auto_breed",
                        "pallet_kitties",
                        ::tracing::Level::TRACE,
                        Some("pallets/kitties/src/lib.rs"),
                        Some(110u32),
                        Some("pallet_kitties"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                MacroCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = CALLSITE.interest();
                    !interest.is_never()
                }
                && CALLSITE.is_enabled(interest)
            {
                let meta = CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = CALLSITE.disabled_span();
                {};
                span
            }
        };
        let __tracing_guard__ = __within_span__.enter();
        {
            ensure_none(origin)?;
            let kitty1 = NftModule::<T>::tokens(Self::class_id(), kitty_id_1)
                .ok_or(Error::<T>::InvalidKittyId)?;
            let kitty2 = NftModule::<T>::tokens(Self::class_id(), kitty_id_2)
                .ok_or(Error::<T>::InvalidKittyId)?;
            Self::do_breed(kitty1.owner, kitty1.data, kitty2.data)?;
        }
        Ok(())
    }
}
/// Dispatchable calls.
///
/// Each variant of this enum maps to a dispatchable function from the associated module.
pub enum Call<T: Config> {
    #[doc(hidden)]
    #[codec(skip)]
    __PhantomItem(
        ::frame_support::sp_std::marker::PhantomData<(T,)>,
        ::frame_support::Never,
    ),
    #[allow(non_camel_case_types)]
    /// Create a new kitty
    create(),
    #[allow(non_camel_case_types)]
    /// Breed kitties
    breed(KittyIndexOf<T>, KittyIndexOf<T>),
    #[allow(non_camel_case_types)]
    /// Transfer a kitty to new owner
    transfer(T::AccountId, KittyIndexOf<T>),
    #[allow(non_camel_case_types)]
    /// Set a price for a kitty for sale
    /// None to delist the kitty
    set_price(KittyIndexOf<T>, Option<BalanceOf<T>>),
    #[allow(non_camel_case_types)]
    /// Buy a kitty
    buy(T::AccountId, KittyIndexOf<T>, BalanceOf<T>),
    #[allow(non_camel_case_types)]
    auto_breed(KittyIndexOf<T>, KittyIndexOf<T>, u32, u128),
}
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl<T: Config> _parity_scale_codec::Encode for Call<T>
    where
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        T::AccountId: _parity_scale_codec::Encode,
        T::AccountId: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        Option<BalanceOf<T>>: _parity_scale_codec::Encode,
        Option<BalanceOf<T>>: _parity_scale_codec::Encode,
        T::AccountId: _parity_scale_codec::Encode,
        T::AccountId: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        BalanceOf<T>: _parity_scale_codec::Encode,
        BalanceOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
    {
        fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output + ?Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                Call::create() => {
                    __codec_dest_edqy.push_byte(0usize as u8);
                }
                Call::breed(ref aa, ref ba) => {
                    __codec_dest_edqy.push_byte(1usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                }
                Call::transfer(ref aa, ref ba) => {
                    __codec_dest_edqy.push_byte(2usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                }
                Call::set_price(ref aa, ref ba) => {
                    __codec_dest_edqy.push_byte(3usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                }
                Call::buy(ref aa, ref ba, ref ca) => {
                    __codec_dest_edqy.push_byte(4usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ca, __codec_dest_edqy);
                }
                Call::auto_breed(ref aa, ref ba, ref ca, ref da) => {
                    __codec_dest_edqy.push_byte(5usize as u8);
                    _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(ca, __codec_dest_edqy);
                    _parity_scale_codec::Encode::encode_to(da, __codec_dest_edqy);
                }
                _ => (),
            }
        }
    }
    impl<T: Config> _parity_scale_codec::EncodeLike for Call<T>
    where
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        T::AccountId: _parity_scale_codec::Encode,
        T::AccountId: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        Option<BalanceOf<T>>: _parity_scale_codec::Encode,
        Option<BalanceOf<T>>: _parity_scale_codec::Encode,
        T::AccountId: _parity_scale_codec::Encode,
        T::AccountId: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        BalanceOf<T>: _parity_scale_codec::Encode,
        BalanceOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
        KittyIndexOf<T>: _parity_scale_codec::Encode,
    {
    }
};
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl<T: Config> _parity_scale_codec::Decode for Call<T>
    where
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        T::AccountId: _parity_scale_codec::Decode,
        T::AccountId: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        Option<BalanceOf<T>>: _parity_scale_codec::Decode,
        Option<BalanceOf<T>>: _parity_scale_codec::Decode,
        T::AccountId: _parity_scale_codec::Decode,
        T::AccountId: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        BalanceOf<T>: _parity_scale_codec::Decode,
        BalanceOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
        KittyIndexOf<T>: _parity_scale_codec::Decode,
    {
        fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> core::result::Result<Self, _parity_scale_codec::Error> {
            match __codec_input_edqy
                .read_byte()
                .map_err(|e| e.chain("Could not decode `Call`, failed to read variant byte"))?
            {
                __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(Call::<T>::create()),
                __codec_x_edqy if __codec_x_edqy == 1usize as u8 => Ok(Call::<T>::breed(
                    {
                        let __codec_res_edqy =
                            <KittyIndexOf<T> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::breed.0`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndexOf<T> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::breed.1`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                __codec_x_edqy if __codec_x_edqy == 2usize as u8 => Ok(Call::<T>::transfer(
                    {
                        let __codec_res_edqy =
                            <T::AccountId as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::transfer.0`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndexOf<T> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::transfer.1`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                __codec_x_edqy if __codec_x_edqy == 3usize as u8 => Ok(Call::<T>::set_price(
                    {
                        let __codec_res_edqy =
                            <KittyIndexOf<T> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::set_price.0`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <Option<BalanceOf<T>> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::set_price.1`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                __codec_x_edqy if __codec_x_edqy == 4usize as u8 => Ok(Call::<T>::buy(
                    {
                        let __codec_res_edqy =
                            <T::AccountId as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::buy.0`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndexOf<T> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::buy.1`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <BalanceOf<T> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::buy.2`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                __codec_x_edqy if __codec_x_edqy == 5usize as u8 => Ok(Call::<T>::auto_breed(
                    {
                        let __codec_res_edqy =
                            <KittyIndexOf<T> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::auto_breed.0`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <KittyIndexOf<T> as _parity_scale_codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::auto_breed.1`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <u32 as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::auto_breed.2`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    {
                        let __codec_res_edqy =
                            <u128 as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(e) => return Err(e.chain("Could not decode `Call::auto_breed.3`")),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                )),
                _ => Err("Could not decode `Call`, variant doesn\'t exist".into()),
            }
        }
    }
};
impl<T: Config> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
    fn get_dispatch_info(&self) -> ::frame_support::dispatch::DispatchInfo {
        match *self {
            Call::create() => {
                let base_weight = T::WeightInfo::create();
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<()>>::weigh_data(&base_weight, ());
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<()>>::classify_dispatch(
                        &base_weight,
                        (),
                    );
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee<()>>::pays_fee(&base_weight, ());
                ::frame_support::dispatch::DispatchInfo {
                    weight,
                    class,
                    pays_fee,
                }
            }
            Call::breed(ref kitty_id_1, ref kitty_id_2) => {
                let base_weight = T::WeightInfo::breed();
                let weight = <dyn ::frame_support::dispatch::WeighData<(
                    &KittyIndexOf<T>,
                    &KittyIndexOf<T>,
                )>>::weigh_data(&base_weight, (kitty_id_1, kitty_id_2));
                let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                    &KittyIndexOf<T>,
                    &KittyIndexOf<T>,
                )>>::classify_dispatch(
                    &base_weight, (kitty_id_1, kitty_id_2)
                );
                let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                    &KittyIndexOf<T>,
                    &KittyIndexOf<T>,
                )>>::pays_fee(&base_weight, (kitty_id_1, kitty_id_2));
                ::frame_support::dispatch::DispatchInfo {
                    weight,
                    class,
                    pays_fee,
                }
            }
            Call::transfer(ref to, ref kitty_id) => {
                let base_weight = T::WeightInfo::transfer();
                let weight = <dyn ::frame_support::dispatch::WeighData<(
                    &T::AccountId,
                    &KittyIndexOf<T>,
                )>>::weigh_data(&base_weight, (to, kitty_id));
                let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                    &T::AccountId,
                    &KittyIndexOf<T>,
                )>>::classify_dispatch(&base_weight, (to, kitty_id));
                let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                    &T::AccountId,
                    &KittyIndexOf<T>,
                )>>::pays_fee(&base_weight, (to, kitty_id));
                ::frame_support::dispatch::DispatchInfo {
                    weight,
                    class,
                    pays_fee,
                }
            }
            Call::set_price(ref kitty_id, ref new_price) => {
                let base_weight = T::WeightInfo::set_price();
                let weight = <dyn ::frame_support::dispatch::WeighData<(
                    &KittyIndexOf<T>,
                    &Option<BalanceOf<T>>,
                )>>::weigh_data(&base_weight, (kitty_id, new_price));
                let class =
                    <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &KittyIndexOf<T>,
                        &Option<BalanceOf<T>>,
                    )>>::classify_dispatch(&base_weight, (kitty_id, new_price));
                let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                    &KittyIndexOf<T>,
                    &Option<BalanceOf<T>>,
                )>>::pays_fee(&base_weight, (kitty_id, new_price));
                ::frame_support::dispatch::DispatchInfo {
                    weight,
                    class,
                    pays_fee,
                }
            }
            Call::buy(ref owner, ref kitty_id, ref max_price) => {
                let base_weight = T::WeightInfo::buy();
                let weight =
                    <dyn ::frame_support::dispatch::WeighData<(
                        &T::AccountId,
                        &KittyIndexOf<T>,
                        &BalanceOf<T>,
                    )>>::weigh_data(&base_weight, (owner, kitty_id, max_price));
                let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                    &T::AccountId,
                    &KittyIndexOf<T>,
                    &BalanceOf<T>,
                )>>::classify_dispatch(
                    &base_weight, (owner, kitty_id, max_price)
                );
                let pays_fee =
                    <dyn ::frame_support::dispatch::PaysFee<(
                        &T::AccountId,
                        &KittyIndexOf<T>,
                        &BalanceOf<T>,
                    )>>::pays_fee(&base_weight, (owner, kitty_id, max_price));
                ::frame_support::dispatch::DispatchInfo {
                    weight,
                    class,
                    pays_fee,
                }
            }
            Call::auto_breed(ref kitty_id_1, ref kitty_id_2, ref _nonce, ref _solution) => {
                let base_weight = 1000;
                let weight = <dyn ::frame_support::dispatch::WeighData<(
                    &KittyIndexOf<T>,
                    &KittyIndexOf<T>,
                    &u32,
                    &u128,
                )>>::weigh_data(
                    &base_weight, (kitty_id_1, kitty_id_2, _nonce, _solution)
                );
                let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                    &KittyIndexOf<T>,
                    &KittyIndexOf<T>,
                    &u32,
                    &u128,
                )>>::classify_dispatch(
                    &base_weight, (kitty_id_1, kitty_id_2, _nonce, _solution)
                );
                let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                    &KittyIndexOf<T>,
                    &KittyIndexOf<T>,
                    &u32,
                    &u128,
                )>>::pays_fee(
                    &base_weight, (kitty_id_1, kitty_id_2, _nonce, _solution)
                );
                ::frame_support::dispatch::DispatchInfo {
                    weight,
                    class,
                    pays_fee,
                }
            }
            Call::__PhantomItem(_, _) => {
                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                    &["internal error: entered unreachable code: "],
                    &match (&"__PhantomItem should never be used.",) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
    }
}
impl<T: Config> ::frame_support::dispatch::GetCallName for Call<T> {
    fn get_call_name(&self) -> &'static str {
        match *self {
            Call::create() => {
                let _ = ();
                "create"
            }
            Call::breed(ref kitty_id_1, ref kitty_id_2) => {
                let _ = (kitty_id_1, kitty_id_2);
                "breed"
            }
            Call::transfer(ref to, ref kitty_id) => {
                let _ = (to, kitty_id);
                "transfer"
            }
            Call::set_price(ref kitty_id, ref new_price) => {
                let _ = (kitty_id, new_price);
                "set_price"
            }
            Call::buy(ref owner, ref kitty_id, ref max_price) => {
                let _ = (owner, kitty_id, max_price);
                "buy"
            }
            Call::auto_breed(ref kitty_id_1, ref kitty_id_2, ref _nonce, ref _solution) => {
                let _ = (kitty_id_1, kitty_id_2, _nonce, _solution);
                "auto_breed"
            }
            Call::__PhantomItem(_, _) => {
                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                    &["internal error: entered unreachable code: "],
                    &match (&"__PhantomItem should never be used.",) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
    }
    fn get_call_names() -> &'static [&'static str] {
        &[
            "create",
            "breed",
            "transfer",
            "set_price",
            "buy",
            "auto_breed",
        ]
    }
}
pub use ::frame_support::traits::GetPalletVersion as _;
impl<T: Config> ::frame_support::traits::GetPalletVersion for Module<T> {
    fn current_version() -> ::frame_support::traits::PalletVersion {
        frame_support::traits::PalletVersion {
            major: 0u16,
            minor: 1u8,
            patch: 0u8,
        }
    }
    fn storage_version() -> Option<::frame_support::traits::PalletVersion> {
        let key = ::frame_support::traits::PalletVersion::storage_key::<
            <T as frame_system::Config>::PalletInfo,
            Self,
        >()
        .expect("Every active pallet has a name in the runtime; qed");
        ::frame_support::storage::unhashed::get(&key)
    }
}
impl<T: Config> ::frame_support::traits::OnGenesis for Module<T> {
    fn on_genesis() {
        frame_support::traits::PalletVersion {
            major: 0u16,
            minor: 1u8,
            patch: 0u8,
        }
        .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
    }
}
impl<T: Config> ::frame_support::dispatch::Clone for Call<T> {
    fn clone(&self) -> Self {
        match *self {
            Call::create() => Call::create(),
            Call::breed(ref kitty_id_1, ref kitty_id_2) => {
                Call::breed((*kitty_id_1).clone(), (*kitty_id_2).clone())
            }
            Call::transfer(ref to, ref kitty_id) => {
                Call::transfer((*to).clone(), (*kitty_id).clone())
            }
            Call::set_price(ref kitty_id, ref new_price) => {
                Call::set_price((*kitty_id).clone(), (*new_price).clone())
            }
            Call::buy(ref owner, ref kitty_id, ref max_price) => {
                Call::buy((*owner).clone(), (*kitty_id).clone(), (*max_price).clone())
            }
            Call::auto_breed(ref kitty_id_1, ref kitty_id_2, ref _nonce, ref _solution) => {
                Call::auto_breed(
                    (*kitty_id_1).clone(),
                    (*kitty_id_2).clone(),
                    (*_nonce).clone(),
                    (*_solution).clone(),
                )
            }
            _ => ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
}
impl<T: Config> ::frame_support::dispatch::PartialEq for Call<T> {
    fn eq(&self, _other: &Self) -> bool {
        match *self {
            Call::create() => {
                let self_params = ();
                if let Call::create() = *_other {
                    self_params == ()
                } else {
                    match *_other {
                        Call::__PhantomItem(_, _) => {
                            ::core::panicking::panic("internal error: entered unreachable code")
                        }
                        _ => false,
                    }
                }
            }
            Call::breed(ref kitty_id_1, ref kitty_id_2) => {
                let self_params = (kitty_id_1, kitty_id_2);
                if let Call::breed(ref kitty_id_1, ref kitty_id_2) = *_other {
                    self_params == (kitty_id_1, kitty_id_2)
                } else {
                    match *_other {
                        Call::__PhantomItem(_, _) => {
                            ::core::panicking::panic("internal error: entered unreachable code")
                        }
                        _ => false,
                    }
                }
            }
            Call::transfer(ref to, ref kitty_id) => {
                let self_params = (to, kitty_id);
                if let Call::transfer(ref to, ref kitty_id) = *_other {
                    self_params == (to, kitty_id)
                } else {
                    match *_other {
                        Call::__PhantomItem(_, _) => {
                            ::core::panicking::panic("internal error: entered unreachable code")
                        }
                        _ => false,
                    }
                }
            }
            Call::set_price(ref kitty_id, ref new_price) => {
                let self_params = (kitty_id, new_price);
                if let Call::set_price(ref kitty_id, ref new_price) = *_other {
                    self_params == (kitty_id, new_price)
                } else {
                    match *_other {
                        Call::__PhantomItem(_, _) => {
                            ::core::panicking::panic("internal error: entered unreachable code")
                        }
                        _ => false,
                    }
                }
            }
            Call::buy(ref owner, ref kitty_id, ref max_price) => {
                let self_params = (owner, kitty_id, max_price);
                if let Call::buy(ref owner, ref kitty_id, ref max_price) = *_other {
                    self_params == (owner, kitty_id, max_price)
                } else {
                    match *_other {
                        Call::__PhantomItem(_, _) => {
                            ::core::panicking::panic("internal error: entered unreachable code")
                        }
                        _ => false,
                    }
                }
            }
            Call::auto_breed(ref kitty_id_1, ref kitty_id_2, ref _nonce, ref _solution) => {
                let self_params = (kitty_id_1, kitty_id_2, _nonce, _solution);
                if let Call::auto_breed(ref kitty_id_1, ref kitty_id_2, ref _nonce, ref _solution) =
                    *_other
                {
                    self_params == (kitty_id_1, kitty_id_2, _nonce, _solution)
                } else {
                    match *_other {
                        Call::__PhantomItem(_, _) => {
                            ::core::panicking::panic("internal error: entered unreachable code")
                        }
                        _ => false,
                    }
                }
            }
            _ => ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
}
impl<T: Config> ::frame_support::dispatch::Eq for Call<T> {}
impl<T: Config> ::frame_support::dispatch::fmt::Debug for Call<T> {
    fn fmt(
        &self,
        _f: &mut ::frame_support::dispatch::fmt::Formatter,
    ) -> ::frame_support::dispatch::result::Result<(), ::frame_support::dispatch::fmt::Error> {
        match *self {
            Call::create() => _f.write_fmt(::core::fmt::Arguments::new_v1(
                &["", ""],
                &match (&"create", &()) {
                    (arg0, arg1) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                    ],
                },
            )),
            Call::breed(ref kitty_id_1, ref kitty_id_2) => {
                _f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (&"breed", &(kitty_id_1.clone(), kitty_id_2.clone())) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                ))
            }
            Call::transfer(ref to, ref kitty_id) => _f.write_fmt(::core::fmt::Arguments::new_v1(
                &["", ""],
                &match (&"transfer", &(to.clone(), kitty_id.clone())) {
                    (arg0, arg1) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                    ],
                },
            )),
            Call::set_price(ref kitty_id, ref new_price) => {
                _f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (&"set_price", &(kitty_id.clone(), new_price.clone())) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                ))
            }
            Call::buy(ref owner, ref kitty_id, ref max_price) => {
                _f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (
                        &"buy",
                        &(owner.clone(), kitty_id.clone(), max_price.clone()),
                    ) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                ))
            }
            Call::auto_breed(ref kitty_id_1, ref kitty_id_2, ref _nonce, ref _solution) => _f
                .write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (
                        &"auto_breed",
                        &(
                            kitty_id_1.clone(),
                            kitty_id_2.clone(),
                            _nonce.clone(),
                            _solution.clone(),
                        ),
                    ) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                )),
            _ => ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
}
impl<T: Config> ::frame_support::traits::UnfilteredDispatchable for Call<T> {
    type Origin = T::Origin;
    fn dispatch_bypass_filter(
        self,
        _origin: Self::Origin,
    ) -> ::frame_support::dispatch::DispatchResultWithPostInfo {
        match self {
            Call::create() => <Module<T>>::create(_origin)
                .map(Into::into)
                .map_err(Into::into),
            Call::breed(kitty_id_1, kitty_id_2) => {
                <Module<T>>::breed(_origin, kitty_id_1, kitty_id_2)
                    .map(Into::into)
                    .map_err(Into::into)
            }
            Call::transfer(to, kitty_id) => <Module<T>>::transfer(_origin, to, kitty_id)
                .map(Into::into)
                .map_err(Into::into),
            Call::set_price(kitty_id, new_price) => {
                <Module<T>>::set_price(_origin, kitty_id, new_price)
                    .map(Into::into)
                    .map_err(Into::into)
            }
            Call::buy(owner, kitty_id, max_price) => {
                <Module<T>>::buy(_origin, owner, kitty_id, max_price)
                    .map(Into::into)
                    .map_err(Into::into)
            }
            Call::auto_breed(kitty_id_1, kitty_id_2, _nonce, _solution) => {
                <Module<T>>::auto_breed(_origin, kitty_id_1, kitty_id_2, _nonce, _solution)
                    .map(Into::into)
                    .map_err(Into::into)
            }
            Call::__PhantomItem(_, _) => {
                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                    &["internal error: entered unreachable code: "],
                    &match (&"__PhantomItem should never be used.",) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
    }
}
impl<T: Config> ::frame_support::dispatch::Callable<T> for Module<T> {
    type Call = Call<T>;
}
impl<T: Config> Module<T> {
    #[doc(hidden)]
    #[allow(dead_code)]
    pub fn call_functions() -> &'static [::frame_support::dispatch::FunctionMetadata] {
        &[
            ::frame_support::dispatch::FunctionMetadata {
                name: ::frame_support::dispatch::DecodeDifferent::Encode("create"),
                arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[]),
                documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    r" Create a new kitty",
                ]),
            },
            ::frame_support::dispatch::FunctionMetadata {
                name: ::frame_support::dispatch::DecodeDifferent::Encode("breed"),
                arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("kitty_id_1"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("KittyIndexOf<T>"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("kitty_id_2"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("KittyIndexOf<T>"),
                    },
                ]),
                documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    r" Breed kitties",
                ]),
            },
            ::frame_support::dispatch::FunctionMetadata {
                name: ::frame_support::dispatch::DecodeDifferent::Encode("transfer"),
                arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("to"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("T::AccountId"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("kitty_id"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("KittyIndexOf<T>"),
                    },
                ]),
                documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    r" Transfer a kitty to new owner",
                ]),
            },
            ::frame_support::dispatch::FunctionMetadata {
                name: ::frame_support::dispatch::DecodeDifferent::Encode("set_price"),
                arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("kitty_id"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("KittyIndexOf<T>"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("new_price"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                            "Option<BalanceOf<T>>",
                        ),
                    },
                ]),
                documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    r" Set a price for a kitty for sale",
                    r" None to delist the kitty",
                ]),
            },
            ::frame_support::dispatch::FunctionMetadata {
                name: ::frame_support::dispatch::DecodeDifferent::Encode("buy"),
                arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("owner"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("T::AccountId"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("kitty_id"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("KittyIndexOf<T>"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("max_price"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("BalanceOf<T>"),
                    },
                ]),
                documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    r" Buy a kitty",
                ]),
            },
            ::frame_support::dispatch::FunctionMetadata {
                name: ::frame_support::dispatch::DecodeDifferent::Encode("auto_breed"),
                arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("kitty_id_1"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("KittyIndexOf<T>"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("kitty_id_2"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("KittyIndexOf<T>"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("_nonce"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("u32"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("_solution"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("u128"),
                    },
                ]),
                documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[]),
            },
        ]
    }
}
impl<T: 'static + Config> Module<T> {
    #[doc(hidden)]
    #[allow(dead_code)]
    pub fn module_constants_metadata(
    ) -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
        #[allow(non_upper_case_types)]
        #[allow(non_camel_case_types)]
        struct DefaultDifficultyDefaultByteGetter<T: Config>(
            ::frame_support::dispatch::marker::PhantomData<(T,)>,
        );
        impl<T: 'static + Config> ::frame_support::dispatch::DefaultByte
            for DefaultDifficultyDefaultByteGetter<T>
        {
            fn default_byte(&self) -> ::frame_support::dispatch::Vec<u8> {
                let value: u32 = T::DefaultDifficulty::get();
                ::frame_support::dispatch::Encode::encode(&value)
            }
        }
        unsafe impl<T: 'static + Config> Send for DefaultDifficultyDefaultByteGetter<T> {}
        unsafe impl<T: 'static + Config> Sync for DefaultDifficultyDefaultByteGetter<T> {}
        &[::frame_support::dispatch::ModuleConstantMetadata {
            name: ::frame_support::dispatch::DecodeDifferent::Encode("DefaultDifficulty"),
            ty: ::frame_support::dispatch::DecodeDifferent::Encode("u32"),
            value: ::frame_support::dispatch::DecodeDifferent::Encode(
                ::frame_support::dispatch::DefaultByteGetter(
                    &DefaultDifficultyDefaultByteGetter::<T>(
                        ::frame_support::dispatch::marker::PhantomData,
                    ),
                ),
            ),
            documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                r" Default difficulty for auto breed",
            ]),
        }]
    }
}
impl<T: Config> ::frame_support::dispatch::ModuleErrorMetadata for Module<T> {
    fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
        <Error<T> as ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
    }
}
fn combine_dna(dna1: u8, dna2: u8, selector: u8) -> u8 {
    (!selector & dna1) | (selector & dna2)
}
impl<T: Config> Module<T> {
    fn kitties(owner: &T::AccountId, kitty_id: KittyIndexOf<T>) -> Option<Kitty> {
        NftModule::<T>::tokens(Self::class_id(), kitty_id).and_then(|x| {
            if x.owner == *owner {
                Some(x.data)
            } else {
                None
            }
        })
    }
    fn random_value(sender: &T::AccountId) -> [u8; 16] {
        let payload = (
            T::Randomness::random_seed(),
            &sender,
            <frame_system::Module<T>>::extrinsic_index(),
        );
        payload.using_encoded(blake2_128)
    }
    fn do_breed(owner: T::AccountId, kitty1: Kitty, kitty2: Kitty) -> DispatchResult {
        {
            if !(kitty1.gender() != kitty2.gender()) {
                {
                    return Err(Error::<T>::SameGender.into());
                };
            }
        };
        let kitty1_dna = kitty1.0;
        let kitty2_dna = kitty2.0;
        let selector = Self::random_value(&owner);
        let mut new_dna = [0u8; 16];
        for i in 0..kitty1_dna.len() {
            new_dna[i] = combine_dna(kitty1_dna[i], kitty2_dna[i], selector[i]);
        }
        let new_kitty = Kitty(new_dna);
        let kitty_id =
            NftModule::<T>::mint(&owner, Self::class_id(), Vec::new(), new_kitty.clone())?;
        Self::deposit_event(RawEvent::KittyBred(owner, kitty_id, new_kitty));
        Ok(())
    }
    fn validate_solution(
        kitty_id_1: KittyIndexOf<T>,
        kitty_id_2: KittyIndexOf<T>,
        nonce: u32,
        solution: u128,
    ) -> bool {
        let payload = (kitty_id_1, kitty_id_2, nonce, solution);
        let hash = payload.using_encoded(blake2_128);
        let hash_value = u128::from_le_bytes(hash);
        let difficulty = T::DefaultDifficulty::get();
        hash_value < (u128::max_value() / difficulty as u128)
    }
    fn run_offchain_worker() -> Result<(), ()> {
        let mut lock =
            StorageLock::<'_, BlockAndTime<frame_system::Module<T>>>::with_block_deadline(
                &b"kitties/lock"[..],
                1,
            );
        let _guard = lock.try_lock().map_err(|_| ())?;
        let random_seed = sp_io::offchain::random_seed();
        let mut rng = RandomNumberGenerator::<BlakeTwo256>::new(random_seed.into());
        let kitty_count =
            TryInto::<u32>::try_into(orml_nft::Module::<T>::next_token_id(Self::class_id()))
                .map_err(|_| ())?;
        const MAX_ITERATIONS: u128 = 500;
        let nonce = Self::auto_breed_nonce();
        let mut remaining_iterations = MAX_ITERATIONS;
        let (kitty_1, kitty_2) = loop {
            let kitty_id_1: KittyIndexOf<T> = rng.pick_u32(kitty_count).into();
            let kitty_id_2: KittyIndexOf<T> = rng.pick_u32(kitty_count).into();
            let kitty_1 = NftModule::<T>::tokens(Self::class_id(), kitty_id_1).ok_or(())?;
            let kitty_2 = NftModule::<T>::tokens(Self::class_id(), kitty_id_2).ok_or(())?;
            if kitty_1.data.gender() != kitty_2.data.gender() {
                break (kitty_id_1, kitty_id_2);
            }
            remaining_iterations -= 1;
            if remaining_iterations == 0 {
                return Err(());
            }
        };
        let solution_prefix = rng.pick_u32(u32::max_value() - 1) as u128;
        for i in 0..remaining_iterations {
            let solution = (solution_prefix << 32) + i;
            if Self::validate_solution(kitty_1, kitty_2, nonce, solution) {
                let _ = SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(
                    Call::<T>::auto_breed(kitty_1, kitty_2, nonce, solution).into(),
                );
                break;
            }
        }
        Ok(())
    }
}
impl<T: Config> frame_support::unsigned::ValidateUnsigned for Module<T> {
    type Call = Call<T>;
    fn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {
        match *call {
            Call::auto_breed(kitty_id_1, kitty_id_2, nonce, solution) => {
                if Self::validate_solution(kitty_id_1, kitty_id_2, nonce, solution) {
                    if nonce != Self::auto_breed_nonce() {
                        return InvalidTransaction::BadProof.into();
                    }
                    AutoBreedNonce::mutate(|nonce| *nonce = nonce.saturating_add(1));
                    ValidTransaction::with_tag_prefix("kitties")
                        .longevity(64_u64)
                        .propagate(true)
                        .build()
                } else {
                    InvalidTransaction::BadProof.into()
                }
            }
            _ => InvalidTransaction::Call.into(),
        }
    }
}
